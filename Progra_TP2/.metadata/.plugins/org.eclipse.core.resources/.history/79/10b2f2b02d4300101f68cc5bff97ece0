package resolucion;

import grafos.*;

import java.util.*;

public class Resolucion {

	public class Coordenada
	{
		private final int x;
		private final int y;
		
		public Coordenada(int x, int y)
		{
			this.x=x;
			this.y=y;
		}
		
		public static double distancia(Coordenada a, Coordenada b)
		{
		    int lx = a.getX() - b.getX(); //Longitud X
		    int ly = a.getY() - b.getY(); //Longitud Y
		    return Math.sqrt(lx * lx + ly * ly); //raiz cuadrada de suma de cuadrados
		    //Se resuelve con pitágoras.
		}

		public int getX() {
			return x;
		}

		public int getY() {
			return y;
		}
		
	}
	
	
	public class Robopuerto
	{
		private String id;
		private final Coordenada coordenada;
		private final Nodo nodo;  
		private final double radio=10;
		
		List<Cofre> cofres_en_radio = new LinkedList<Cofre>();
		
		public Robopuerto(int x, int y, String id)
		{
			this.id=id;
			this.coordenada = new Coordenada(x, y);
			this.nodo = new Nodo(x+x*y, id);//Para tener id único
		}

		public Nodo getNodo() {
			return nodo;
		}

		public Coordenada getCoordenada() {
			return coordenada;
		}

		public double getRadio() {
			return radio;
		}
		
		public void agregar_cofreAccesible(Cofre cofre)
		{
			this.cofres_en_radio.add(cofre);
		}

		public String getId() {
			return id;
		}

		public List<Cofre> getCofres_en_radio() {
			return cofres_en_radio;
		}
		
		
		
	}
	
	public class Cofre
	{
		private String id;
		private final Coordenada coordenada;
		private final Nodo nodo;  
		
		private Robopuerto rp_mas_cercano;
		private double distancia_rp;
		
		public Cofre(int x, int y, String id)
		{
			this.id=id;
			this.coordenada = new Coordenada(x, y);
			this.nodo = new Nodo(x+x*y, id); //Para tener id único
		}

		public Nodo getNodo() {
			return nodo;
		}

		public Coordenada getCoordenada() {
			return coordenada;
		}

		public Robopuerto getRp_mas_cercano() {
			return rp_mas_cercano;
		}

		public void setRp_mas_cercano(Robopuerto rp_mas_cercano, double distancia) {
			this.rp_mas_cercano = rp_mas_cercano;
			setDistancia_rp(distancia);
		}

		public double getDistanciaRP_minima() {
			return distancia_rp;
		}

		private void setDistancia_rp(double distancia_rp) {
			this.distancia_rp = distancia_rp;
		}

		public String getId() {
			return id;
		}		
		
		
	}
	
	public class Robot
	{
		private String id;
		private final int carga_max = 20;
		private int carga_actual;
		private Nodo nodo_actual;
		private double bateria;
		
		public Robot(String id, Nodo nodo_inicial)
		{
			this.nodo_actual = nodo_inicial;
			this.bateria=100;
			this.carga_actual=0;
		}
		
		public void viajar(Nodo nodo_destino, double costo)
		{
			//Mi Arista está implementada con int para el peso
			//Para el algoritmo que vayamos a usar, debo cambiar eso y ver como fluctuan los
			//resultados...
			try {
			    if (this.bateria - costo> 0) {
			        this.bateria -= costo;
			        this.nodo_actual = nodo_destino;
			    } else {
			        throw new Exception("No hay suficiente batería para realizar la acción.");
			    }
			} catch (Exception e) {
			    System.out.println("Error: " + e.getMessage());
			}
		}

		public String getId() {
			return id;
		}

		public int getCarga_max() {
			return carga_max;
		}

		public int getCarga_actual() {
			return carga_actual;
		}

		public Nodo getNodo_actual() {
			return nodo_actual;
		}

		public double getBateria() {
			return bateria;
		}
		
		
	}
	
	
	public void main()
	{
		   // Robopuertos
	    Robopuerto rp1 = new Robopuerto(0, 0, "RP1");
	    Robopuerto rp2 = new Robopuerto(15, 0, "RP2"); // Más cerca
	    
	    // Cofres
	    Cofre c1 = new Cofre(5, 0, "C1");     // cerca de RP1
	    Cofre c2 = new Cofre(0, 7, "C2");     // cerca de RP1
	    Cofre c3 = new Cofre(20, 0, "C3");    // cerca de RP2
	    Cofre c4 = new Cofre(15, 7, "C4");    // cerca de RP2
	    Cofre c5 = new Cofre(8, 0, "C5");     // en medio, dentro de ambos (sin estar en límite)
	    Cofre c6 = new Cofre(50, 50, "C6");   // fuera de ambos
	    
	    Robopuerto[] robopuertos = {rp1, rp2};
	    Cofre[] cofres = {c1, c2, c3, c4, c5, c6};
	    
	    Grafo grafo = armado_inicial(robopuertos, cofres);
	    
	    
	    
	}
	
	public Grafo armado_inicial(Robopuerto[] robopuertos, Cofre[] cofres)
	{ 
	    Grafo grafo = new Grafo(false); //No es dirigido, los caminos son doble sentido
	    
	    for(Robopuerto rp : robopuertos)
	    	grafo.addNodo(rp.getNodo());
	    
	    for(Cofre cofre : cofres)
	    	grafo.addNodo(cofre.getNodo());

	    
	    for(Robopuerto rp : robopuertos)
	    {
	    	for(Cofre cofre : cofres)
	    	{	
	    		Coordenada coord_cofre = cofre.getCoordenada();
	    		Coordenada coord_rp = rp.getCoordenada();
	    		
	    		double distancia = Coordenada.distancia(coord_cofre, coord_rp);	
	    		
	    		if(distancia < rp.getRadio())
	    		{
		    		Nodo nodo_cofre = cofre.getNodo();
		    		Nodo nodo_rp = rp.getNodo();
	    			grafo.addArista(nodo_cofre, nodo_rp, distancia); 
	    			
	    			if(distancia < cofre.getDistanciaRP_minima())
	    			{
	    				cofre.setRp_mas_cercano(rp, distancia);
	    			}
	    			//Como no es dirigido, tambien se agrega el inverso.
	    		}
	    	} 
	    	
	    	//Y falta agregar Las aristas entre cada nodo que esté contenido en un radio.
	    	//Si hay un cofre en ambos radios, eso conectaria la red.
	    	//Si consideramos union de red aunque no haya cofre, necesitamos una arista entre
	    	//los dos robopuertos
	    }
	    
	    return grafo;
	}
	
	
	
	
//Fin
}
